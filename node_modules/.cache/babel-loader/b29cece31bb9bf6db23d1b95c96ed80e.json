{"ast":null,"code":"import { normalizeCategory } from './common';\n\nfunction getCategory(k, taxonomy) {\n  if (k === -1) {\n    return '';\n  }\n\n  return taxonomy[k]['name'];\n}\n\nfunction toFinalForm(data) {\n  let headers = data.table.columns;\n  const colidx = {};\n\n  for (var i = 0; i < headers.length; i++) {\n    colidx[headers[i]] = i;\n  }\n\n  const features = [];\n  data.table.data.forEach((row, i) => {\n    let feature = {\n      'type': 'Feature',\n      'properties': {\n        'idx': i,\n        'company': row[colidx['company']],\n        'city': data.cities[row[colidx['city']]],\n        'tax1': getCategory(row[colidx['tax1']], data.taxonomy),\n        'tax2': getCategory(row[colidx['tax2']], data.taxonomy),\n        'tax3': getCategory(row[colidx['tax3']], data.taxonomy),\n        'website': row[colidx['website']],\n        'notes': row[colidx['notes']]\n      },\n      'geometry': {\n        'type': 'Point',\n        'coordinates': [row[colidx['lng']], row[colidx['lat']]]\n      }\n    }; // canonicalize categories for use as labels\n\n    ['tax1', 'tax2', 'tax3'].forEach(label => {\n      const newprop = `${label}sanitized`;\n      let category = feature.properties[label];\n      feature.properties[newprop] = normalizeCategory(category);\n    });\n    features.push(feature);\n  });\n  return {\n    geojson: {\n      type: 'FeatureCollection',\n      features: features\n    },\n    taxonomy: data.taxonomy\n  };\n}\n\nexport function fetchMapData(mapId) {\n  let url = process.env.PUBLIC_URL + `/data/${mapId}.json`;\n  return fetch(url).then(r => r.json()).then(toFinalForm);\n}","map":{"version":3,"sources":["/Users/laurenjanicke/aes-sustainability/src/data-loader.js"],"names":["normalizeCategory","getCategory","k","taxonomy","toFinalForm","data","headers","table","columns","colidx","i","length","features","forEach","row","feature","cities","label","newprop","category","properties","push","geojson","type","fetchMapData","mapId","url","process","env","PUBLIC_URL","fetch","then","r","json"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,UAAlC;;AAEA,SAASC,WAAT,CAAqBC,CAArB,EAAwBC,QAAxB,EAAkC;AAChC,MAAID,CAAC,KAAK,CAAC,CAAX,EAAc;AACZ,WAAO,EAAP;AACD;;AACD,SAAOC,QAAQ,CAACD,CAAD,CAAR,CAAY,MAAZ,CAAP;AACD;;AAED,SAASE,WAAT,CAAqBC,IAArB,EAA2B;AACzB,MAAIC,OAAO,GAAGD,IAAI,CAACE,KAAL,CAAWC,OAAzB;AACA,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAACK,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvCD,IAAAA,MAAM,CAACH,OAAO,CAACI,CAAD,CAAR,CAAN,GAAqBA,CAArB;AACD;;AACD,QAAME,QAAQ,GAAG,EAAjB;AACAP,EAAAA,IAAI,CAACE,KAAL,CAAWF,IAAX,CAAgBQ,OAAhB,CAAwB,CAACC,GAAD,EAAMJ,CAAN,KAAY;AAClC,QAAIK,OAAO,GAAG;AACZ,cAAQ,SADI;AAEZ,oBAAc;AACZ,eAAOL,CADK;AAEZ,mBAAWI,GAAG,CAACL,MAAM,CAAC,SAAD,CAAP,CAFF;AAGZ,gBAAQJ,IAAI,CAACW,MAAL,CAAYF,GAAG,CAACL,MAAM,CAAC,MAAD,CAAP,CAAf,CAHI;AAIZ,gBAAQR,WAAW,CAACa,GAAG,CAACL,MAAM,CAAC,MAAD,CAAP,CAAJ,EAAsBJ,IAAI,CAACF,QAA3B,CAJP;AAKZ,gBAAQF,WAAW,CAACa,GAAG,CAACL,MAAM,CAAC,MAAD,CAAP,CAAJ,EAAsBJ,IAAI,CAACF,QAA3B,CALP;AAMZ,gBAAQF,WAAW,CAACa,GAAG,CAACL,MAAM,CAAC,MAAD,CAAP,CAAJ,EAAsBJ,IAAI,CAACF,QAA3B,CANP;AAOZ,mBAAWW,GAAG,CAACL,MAAM,CAAC,SAAD,CAAP,CAPF;AAQZ,iBAASK,GAAG,CAACL,MAAM,CAAC,OAAD,CAAP;AARA,OAFF;AAYZ,kBAAY;AACV,gBAAQ,OADE;AAEV,uBAAe,CAACK,GAAG,CAACL,MAAM,CAAC,KAAD,CAAP,CAAJ,EAAqBK,GAAG,CAACL,MAAM,CAAC,KAAD,CAAP,CAAxB;AAFL;AAZA,KAAd,CADkC,CAkBlC;;AACA,KAAC,MAAD,EAAS,MAAT,EAAiB,MAAjB,EAAyBI,OAAzB,CAAiCI,KAAK,IAAI;AACxC,YAAMC,OAAO,GAAI,GAAED,KAAM,WAAzB;AACA,UAAIE,QAAQ,GAAGJ,OAAO,CAACK,UAAR,CAAmBH,KAAnB,CAAf;AACAF,MAAAA,OAAO,CAACK,UAAR,CAAmBF,OAAnB,IAA8BlB,iBAAiB,CAACmB,QAAD,CAA/C;AACD,KAJD;AAKAP,IAAAA,QAAQ,CAACS,IAAT,CAAcN,OAAd;AACD,GAzBD;AA0BA,SAAO;AACLO,IAAAA,OAAO,EAAE;AACPC,MAAAA,IAAI,EAAE,mBADC;AAEPX,MAAAA,QAAQ,EAAEA;AAFH,KADJ;AAKLT,IAAAA,QAAQ,EAAEE,IAAI,CAACF;AALV,GAAP;AAOD;;AAED,OAAO,SAASqB,YAAT,CAAsBC,KAAtB,EAA6B;AAClC,MAAIC,GAAG,GAAGC,OAAO,CAACC,GAAR,CAAYC,UAAZ,GAA0B,SAAQJ,KAAM,OAAlD;AACA,SAAOK,KAAK,CAACJ,GAAD,CAAL,CAAWK,IAAX,CAAgBC,CAAC,IAAIA,CAAC,CAACC,IAAF,EAArB,EAA+BF,IAA/B,CAAoC3B,WAApC,CAAP;AACD","sourcesContent":["import { normalizeCategory } from './common';\n\nfunction getCategory(k, taxonomy) {\n  if (k === -1) {\n    return '';\n  }\n  return taxonomy[k]['name'];\n}\n\nfunction toFinalForm(data) {\n  let headers = data.table.columns;\n  const colidx = {};\n  for (var i = 0; i < headers.length; i++) {\n    colidx[headers[i]] = i;\n  }\n  const features = [];\n  data.table.data.forEach((row, i) => {\n    let feature = {\n      'type': 'Feature',\n      'properties': {\n        'idx': i,\n        'company': row[colidx['company']],\n        'city': data.cities[row[colidx['city']]],\n        'tax1': getCategory(row[colidx['tax1']], data.taxonomy),\n        'tax2': getCategory(row[colidx['tax2']], data.taxonomy),\n        'tax3': getCategory(row[colidx['tax3']], data.taxonomy),\n        'website': row[colidx['website']],\n        'notes': row[colidx['notes']],\n      },\n      'geometry': {\n        'type': 'Point',\n        'coordinates': [row[colidx['lng']], row[colidx['lat']]],\n      },\n    };\n    // canonicalize categories for use as labels\n    ['tax1', 'tax2', 'tax3'].forEach(label => {\n      const newprop = `${label}sanitized`;\n      let category = feature.properties[label];\n      feature.properties[newprop] = normalizeCategory(category);\n    });\n    features.push(feature);\n  });\n  return {\n    geojson: {\n      type: 'FeatureCollection',\n      features: features,\n    },\n    taxonomy: data.taxonomy,\n  }\n}\n\nexport function fetchMapData(mapId) {\n  let url = process.env.PUBLIC_URL + `/data/${mapId}.json`;\n  return fetch(url).then(r => r.json()).then(toFinalForm);\n}\n"]},"metadata":{},"sourceType":"module"}